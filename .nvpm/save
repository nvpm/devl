
current proj {

" auto/proj.vim
" once {

if !NVPMTEST&&exists('PROJAUTOLOAD')|finish|else|let PROJAUTOLOAD=1|endif

" end-once}
" priv {

let s:tree = {}
let s:curr = {}

let s:curr.p = 0
let s:curr.w = 0
let s:curr.t = 0
let s:curr.b = 0

fu! s:curr.item(type,tree) "{

  if a:type == 'p'
    return a:tree.list[self.p]
  endif
  if a:type == 'w'
    return a:tree.list[self.p].list[self.w]
  endif
  if a:type == 't'
    return a:tree.list[self.p].list[self.w].list[self.t]
  endif
  if a:type == 'b'
    return a:tree.list[self.p].list[self.w].list[self.t].list[self.b]
  endif

  return {}

endf "}
fu! s:curr.list(type,tree) "{

  if a:type == 'p'
    return a:tree.list
  endif
  if a:type == 'w'
    return a:tree.list[self.p].list
  endif
  if a:type == 't'
    return a:tree.list[self.p].list[self.w].list
  endif
  if a:type == 'b'
    return a:tree.list[self.p].list[self.w].list[self.t].list
  endif

  return []

endf "}
fu! s:curr.name(type)      "{

  if a:type == 'p'
    return self.p
  endif
  if a:type == 'w'
    return self.p.'.'.self.w
  endif
  if a:type == 't'
    return self.p.'.'.self.w.'.'.self.t
  endif
  if a:type == 'b'
    return self.p.'.'.self.w.'.'.self.t.'.'.self.b
  endif

  return ''

endf "}
fu! s:curr.buff(tree)      "{

  let buff = self.item('b',a:tree)

  if exists('buff.comm')
    if !empty(buff.comm)
      exec 'edit term://.//'.buff.comm
    elseif !empty(buff.name) && empty(buff.comm)
      exec 'edit term://.//'.buff.name
    else
      exec 'buffer|terminal'
    endif
  else
    if !empty(buff.file)
      exec 'edit '.buff.file
    elseif !empty(buff.name) && empty(buff.file)
      exec 'edit '.buff.name
    else
      exec 'edit '.self.name('b')
    endif
  endif

endf "}

" }
" publ {

let s:line = {}

fu! s:load() dict "{
  let self.tree = flux#flux(self.file)
  if !empty(self.tree)
    call s:curr.buff(self.tree)
    call s:line.show(self.tree)
  endif
endf "}

fu! s:line.init() "{
  let botc = ' ⬤ %f'
  let botr = '%y%m ⬤ %l,%c/%P'
  let self.git = ''
  let self.visible      = 0
  let self.bottomcenter = get(g:,'proj_bottomcenter'  ,botc)
  let self.bottomright  = get(g:,'proj_bottomright'   ,botr)
  let self.closure      = get(g:,'proj_closure'       ,1   )
  let self.projname     = get(g:,'proj_projname'      ,1   )
  let self.gitinfo      = get(g:,'proj_git_info'      ,0   )
  let self.gitdelayms   = get(g:,'proj_git_info_delay',2000)
  let self.gittimer     = 0
endf "}
fu! s:line.topl(tree) "{

  let line    = ''
  let space   = ' '
  let currproj = s:curr.item('p',a:tree)
  let currwksp = s:curr.item('w',a:tree)
  let currtab  = s:curr.item('t',a:tree)

  for tab in s:curr.list('t',a:tree)
    let iscurr = tab.name == currtab.name
    let line  .= '%#ProjTabs'
    let line  .= iscurr ? 'Sel#' : '#'
    let line  .= self.closure && iscurr ? '['.space : ' '.space
    let line  .= tab.name
    let line  .= self.closure && iscurr ? space.']' : ' '.space
  endfor

  let line .= '%#ProjTabsFill#'

  let workspaces = s:curr.list('w',a:tree)
  let w = []

  for wksp in s:curr.list('w',a:tree)
    let iscurr = wksp.name == currwksp.name
    let right = ''
    let right .= '%#ProjWksp'
    let right .= iscurr ? 'Sel#' : '#'
    let right .= self.closure && iscurr ? '['.space : ' '.space
    let right .= wksp.name
    let right .= self.closure && iscurr ? space.']' : ' '.space
    call add(w,right)
  endfor

  let line .= '%='
  let line .= join(reverse(w))

  let line .= self.projname?'%#ProjProjSel#'.' '.currproj.name.' ':''

  return line

endf "}
fu! s:line.botl(tree) "{

  let space   = ' '
  let line  = ''

  let currbuf = s:curr.item('b',a:tree)

  for buff in s:curr.list('b',a:tree)
    let iscurr = buff.name == currbuf.name
    let line  .= '%#ProjBuff'
    let line  .= iscurr ? 'Sel#' : '#'
    let line  .= self.closure && iscurr ? '['.space : ' '.space
    let line  .= buff.name
    let line  .= self.closure && iscurr ? space.']' : ' '.space
  endfor

  "let line .= self.git
  let line .= '%#ProjBuffFill#'
  let line .= self.bottomcenter
  let line .= '%='
  let line .= self.bottomright

  return line

endf "}
fu! s:line.show(tree) "{

  "if self.gitinfo && !self.gittimer
    "let self.gittimer = timer_start(self.gitdelayms,
          "\'NVPMGITTIMER',{'repeat':-1})
  "endif

  "if !self.linesaved
    "let self.showtabline = &showtabline
    "let self.laststatus  = &laststatus
  "endif

  set tabline=%!s:line.topl()
  set statusline=%!s:line.botl()

  set showtabline=2
  set laststatus=2

  let self.visible = 1

endf "}
fu! s:line.hide(    ) "{

  set showtabline=0
  set laststatus=0

  "set tabline=%#Normal#
  "set statusline=%#Normal#
  "set tabline=%#Normal#
  "set statusline=%#Normal#

  let self.visible = 0

endf "}
fu! s:line.swap(tree) "{

  if !empty(self.tree)|echo 'NVPM: load a project file first'|return|endif
  if self.visible
    call self.hide()
  else
    call self.show()
  endif

endf "}

" }
" objc {

fu! proj#proj() " {

  let proj = {}
  let proj.load = function('s:load')
  let proj.file = ''

  call s:line.init()

  return proj

endf "}
fu! proj#load(pf,self) " {

  let self = a:self
  let self.file = '.nvpm/proj/'.a:pf
  call self.load()

endf "}

" }


}


" old autoload/flux.vim {
finish
" save {

fu! s:flux.init() "{

  let self.type = ''
  let self.data = s:data.strc

endf "}
fu! s:flux.flux() "{

  if s:patt.flux()|return|endif

  let self.name = self.content
  let self.data[self.name]      = {}
  let self.data[self.name].vars = {}
  let self.data[self.name].dict = {}

  while !s:patt.iend() && !s:patt.endf()
    call self.vars()
    call self.dict()
    call s:file.next()
  endwhile

endf "}
fu! s:flux.vars() "{

  if s:patt.vars()|return|endif
  let self.type = 'vars'
  call self.remv()
  call self.eval()
  call extend(self.data[self.name].vars,self.content)

endf "}
fu! s:flux.dict() "{

  if s:patt.dict()|return|endif
  let self.type = 'dict'
  call self.remv()
  call self.eval()
  call self.extd()

endf "}
fu! s:flux.remv() "{

  for type in keys(self.data[self.name])
    if type == self.type|continue|endif
    let dict = self.data[self.name][type]
    for key in keys(self.content)
      if has_key(dict,key)|call remove(dict,key)|endif
    endfor
  endfor

endf "}
fu! s:flux.extd() "{

  let key = keys(self.content)
  let key = len(key) == 1 ? key[0] : ''
  if has_key(self.data[self.name].dict,key) && !empty(key)
    call extend(self.data[self.name].dict[key],self.content[key])
  else
    call extend(self.data[self.name].dict,self.content)
  endif

  "" [TODO-mdep]: multi-depth extend

endf "}
fu! s:flux.eval() "{

  "" loop over content values
  "" check if value is a variable reference
  "" find variable in s:data.strc for self.name
  "" get value of variable
  "" replace that value into self.content for that key

  let s:data.dbug = 1

  ""if self.type == 'vars'
    ""for pair in items(self.content)
      ""echo matchstr(pair[1],'^\$\('.'[a-zA-Z0-9_]\+'.'\)')
    ""endfor
  ""endif

  ""for entry in keys(self.content)
    ""echo self.type entry self.content[entry]
  ""endfor
  ""echo '------------------'
  ""let s:dbug._show = 1

endf "}

" guards    {

let s:name = 'nvpmflux'

" }
" classes   {

let s:patt = {}
let s:flux = {}
let s:file = {}
let s:data = {}
let g:flux = {}
"   s:data  "{

fu! s:data.init() "{
  let self.strc = {}
  let self.dbug = 0
endf "}
fu! s:data.show() "{

  if !self.dbug|return|endif

  let d = self.strc

  for k1 in keys(self.strc)
    echo k1
    echo repeat(' ',len(k1)).'vars'
    "for k2 in keys(d[k1].vars) " over vars {
      let s   = repeat(' ',len(k1)+len('vars'))
      let key = string(k2)
      let val = string(d[k1].vars[k2])
      echo s.key.' = '.val
    "endfor "}
    echo repeat(' ',len(k1)).'dict'
    "for pair in items(d[k1].dict) " over dict {
      let s   = repeat(' ',len(k1))
      let key = string(pair[0])
      let val = string(pair[1])
      echo s .s.key ':' val
    "endfor "}
  endfor

endf "}

"}
"   s:patt  "{

fu! s:patt.init() "{

  "" common patterns {

    let eq = '='
    let bl = '\['
    let br = '\]'
    let cm = ',*'
    let pl = '\('
    let pr = '\)*'
    let s  = '\s*'
    let b  = '^'
    let e  = '$'

  ""}
  "" middle patterns {

    let n1  = '[a-zA-Z0-9_]\+'
    let n2  = '[a-zA-Z0-9_.]\+'
    let v1  = '[a-zA-Z0-9_.#]\+'
    let s   = '\s*'
    let d   = '\$\='
    let v   = d.v1

    "" TODO: see it for this case 'var = [fg=abg=a,md=a]'
    let vars1 = pl. s.n1.s . eq . s.v.s . cm .pr
    let vars2 =     s.n2.s . eq . s.bl.s. vars1 . s. br

  "" }
  "" object patterns {

    let self._flux = b. 'flux'.s. '\(' .n1. '\).*' .e
    let self._vars = b. vars1                      .e
    let self._dict = b. vars2                      .e
    let self._end  = b. '\s*end.*'                 .e
    let self._endf = '---'
    let self.n1 = n1
    let self.n2 = n2
    let self.v1 = v1

  "" }

endf "}
fu! s:patt.flux() "{

  let match = matchlist(s:file.line,self._flux)
  if empty(match)|return 1|endif
  let s:flux.content = match[1]
  return 0

endf "}
fu! s:patt.vars() "{

  let match = matchstr(s:file.line,self._vars)
  if empty(match)|return 1|endif
  let s:flux.content = match
  call self.brac()
  return 0

endf "}
fu! s:patt.dict() "{

  let match = matchstr(s:file.line,self._dict)
  if empty(match)|return 1|endif

  let match = split(match,'\s*=\s*[\s*')
  let name  = trim(match[0])
  if  name[0] == '.'|return 1|endif
  let s:flux.content = substitute(match[1],']','','')
  call self.brac()

  let sname = split(name,'\.')
  if  sname[0] != name
    let s = '{'
    let l = len(sname)
    while !empty(sname)
      let n = remove(sname,0)
      let s .= "'".n ."':{"
    endwhile
    let s = s[:-2]
    let s.= string(s:flux.content)
    "let s.= repeat('}',l) " }
    exec 'let s:flux.content = '.s
  else
    let s:flux.content = {name:s:flux.content}
  endif
  return 0

endf "}
fu! s:patt.brac() "{

  let pair = split(s:flux.content,',')
  let dict = {}
  for item in pair
    let item = split(item,'=')
    let  key = len(item) >= 1 ? trim(item[0]) : ''
    let  val = len(item) == 2 ? trim(item[1]) : ''
    if empty(key)|continue|endif
    let dict[key] = val
  endfor

  let s:flux.content = dict
endf "}
fu! s:patt.iend() "{
  return !empty(matchstr(s:file.line,self._end))
endf "}
fu! s:patt.endf() "{
  return !empty(matchstr(s:file.line,'^\s*'.self._endf.'\s*$'))
endf "}

"}
"   s:flux  "{

fu! s:flux.init() "{

  let self.type = ''
  let self.data = s:data.strc

endf "}
fu! s:flux.flux() "{

  if s:patt.flux()|return|endif

  let self.name = self.content
  let self.data[self.name]      = {}
  let self.data[self.name].vars = {}
  let self.data[self.name].dict = {}

  while !s:patt.iend() && !s:patt.endf()
    call self.vars()
    call self.dict()
    call s:file.next()
  endwhile

endf "}
fu! s:flux.vars() "{

  if s:patt.vars()|return|endif
  let self.type = 'vars'
  call self.remv()
  call self.eval()
  call extend(self.data[self.name].vars,self.content)

endf "}
fu! s:flux.dict() "{

  if s:patt.dict()|return|endif
  let self.type = 'dict'
  call self.remv()
  call self.eval()
  call self.extd()

endf "}
fu! s:flux.remv() "{

  for type in keys(self.data[self.name])
    if type == self.type|continue|endif
    let dict = self.data[self.name][type]
    for key in keys(self.content)
      if has_key(dict,key)|call remove(dict,key)|endif
    endfor
  endfor

endf "}
fu! s:flux.extd() "{

  let key = keys(self.content)
  let key = len(key) == 1 ? key[0] : ''
  if has_key(self.data[self.name].dict,key) && !empty(key)
    call extend(self.data[self.name].dict[key],self.content[key])
  else
    call extend(self.data[self.name].dict,self.content)
  endif

  "" [TODO-mdep]: multi-depth extend

endf "}
fu! s:flux.eval() "{

  "" loop over content values
  "" check if value is a variable reference
  "" find variable in s:data.strc for self.name
  "" get value of variable
  "" replace that value into self.content for that key

  let s:data.dbug = 1

  ""if self.type == 'vars'
    ""for pair in items(self.content)
      ""echo matchstr(pair[1],'^\$\('.'[a-zA-Z0-9_]\+'.'\)')
    ""endfor
  ""endif

  ""for entry in keys(self.content)
    ""echo self.type entry self.content[entry]
  ""endfor
  ""echo '------------------'
  ""let s:dbug._show = 1

endf "}

"}
"   s:file  "{

fu! s:file.init() "{

  let self.path    = ''
  let self.line    = ''
  let self.lines   = []

endf "}
fu! s:file.read() "{

  if filereadable(self.path)
    let self.lines = readfile(self.path)
    let self.lines+= [s:patt._endf]
  else
    call s:mesg()
    return 1
  endif
  return empty(self.lines)

endf "}
fu! s:file.next() "{
  let self.line = trim(remove(self.lines,0))
  return 1
endf "}

"}

"}
" interface {

fu! g:flux.init() "{
  let self.path = ''
  let self.data = s:flux.data
  let self.vers = 'v0.0.0'
endf "}
fu! g:flux.read() "{

  let s:file.path = self.path
  if  s:file.read()|return|endif

  while !s:patt.endf()
    call s:file.next()
    call s:flux.flux()
  endwhile

endf "}
fu! g:flux.test() "{

  execute 'source '.expand("<sfile>:p:h").'/plug/'.s:name.'.vim'
  let g:flux.path = 'inpt/flux.inp'
  call g:flux.read()
  call s:data.show()

endf "}

"}
" helpers   {

fu! s:mesg() "{

  echohl NVPMFluxTitle
  echon 'NVPM FLUX'
  echohl None
  echon ': Unable to read file '
  echohl SpellBad
  echon s:file.path
  echohl None

endf "}

" }
" inits     {

call s:data.init()
call s:file.init()
call s:patt.init()
call s:flux.init()
call g:flux.init()

" }
" debuging  {

let s:dbug = {}

fu! s:dbug.test() "{

  execute 'source '.expand("<sfile>:p:h").'/plug/'.s:name.'.vim'
  let g:flux.path = 'inpt/flux.inp'
  call g:flux.read()
  call s:data.show()

endf "}


" }
" commands  {

command! NVPMFluxVers echo g:flux.vers
"command! NVPMTest call s:dbug.test()

" }

" }
" }
" old test/init.vim     {

"so plug/flux/autoload/flux.vim
"so plug/file/autoload/file.vim

"let flux = flux#flux()
"let flux.proj.orig = 'data/flux/data'
"call flux.proj.load()
""call flux.proj.show()

"echo flux.proj.tree

" }
" proj plugin syntax {

let s:proj = {}

"fu! s:proj.load() "{

  "if !self.read()|return 0|endif

  "let tree = {}

  "let tree.file = self.orig
  "let tree.name = fnamemodify(tree.file,':t')
  "let tree.root = '.'
  "let tree.list = []
  "let tree.last = 0

  "for self.i in range(len(self.lines))

    "let line = self.lines[self.i]

    "let comment = match(line,'#')
    "if comment + 1|let line = line[0:comment-1]|endif
    "let line = trim(line)

    "if !empty(matchstr(line,'^\s*---.*$'))|break|endif
    "if  empty(line)|continue|endif

    "" Project File 'name' {

    "let self.match = matchlist(line,s:rgex.proj.name)
    "let disabled   = trim(get(self.match,1)) == '-'
    "if !disabled|let tree.name=get(self.match,2,tree.name)|endif

    "" }
    "" Project File 'root' {

    "let self.match = matchlist(line,s:rgex.proj.root)
    "let disabled   = trim(get(self.match,1)) == '-'
    "if !disabled|let tree.root=get(self.match,2,tree.root)|endif

    "" }
    "" Project File 'proj' {

    "let self.match = matchlist(line,s:rgex.proj.proj)
    "let disabled   = trim(get(self.match,1)) == '-'

    "if !disabled && !empty(self.match)|let tree.list+= [self.proj()]|endif

    "" }

  "endfor

  "unlet self.i

  "return tree

"endf "}
"fu! s:proj.proj() "{

  "let node       = {}
  "let node.list  = []
  "let self.match = split(self.match[2],':')
  "let node.name = (len(self.match)>=1)?trim(self.match[0]):''
  "let node.root = (len(self.match)>=2)?trim(self.match[1]):''
  "let node.last = 0

  "for self.p in range(self.i+1,len(self.lines)-1)
    "let line = self.lines[self.p]
    "let self.match = matchlist(line,s:rgex.proj.wksp)
    "if match(line,s:rgex.proj.proj)+1|break
    "elseif !empty(self.match)
      "call add(node.list,self.wksp())
    "endif
  "endfor

  "unlet self.p

  "return node

"endf "}
"fu! s:proj.wksp() "{

  "let node       = {}
  "let node.list  = []
  "let self.match = split(self.match[2],':')
  "let node.name = (len(self.match)>=1)?trim(self.match[0]):''
  "let node.root = (len(self.match)>=2)?trim(self.match[1]):''
  "let node.last = 0

  "for self.w in range(self.p+1,len(self.lines)-1)
    "let line = self.lines[self.w]
    "let self.match = matchlist(line,s:rgex.proj.tabs)
    "if match(line,s:rgex.proj.wksp)+1|break
    "elseif !empty(self.match)
      "call add(node.list,self.tabs())
    "endif
  "endfor

  "unlet self.w

  "return node

"endf "}
"fu! s:proj.tabs() "{

  "let node       = {}
  "let node.list  = []
  "let self.match = split(self.match[2],':')
  "let node.name = (len(self.match)>=1)?trim(self.match[0]):''
  "let node.root = (len(self.match)>=2)?trim(self.match[1]):''
  "let node.last = 0

  "for self.t in range(self.w+1,len(self.lines)-1)
    "let line = self.lines[self.t]
    "let fmatch = matchlist(line,s:rgex.proj.file)
    "let tmatch = matchlist(line,s:rgex.proj.term)
    "if match(line,s:rgex.proj.tabs)+1|break
    "elseif !empty(fmatch)
      "let self.match = fmatch
      "call add(node.list,self.file())
    "elseif !empty(tmatch)
      "let self.match = tmatch
      "call add(node.list,self.term())
    "endif
  "endfor

  "unlet self.t

  "return node

"endf "}
"fu! s:proj.file() "{

  "let node       = {}
  "let self.match = split(self.match[2],':')
  "let node.name  = (len(self.match)>=1)?trim(self.match[0]):''
  "let node.file  = (len(self.match)>=2)?trim(self.match[1]):''

  "return node

"endf "}
"fu! s:proj.term() "{

  "let node       = {}
  "let self.match = split(self.match[2],':')
  "let node.name  = (len(self.match)>=1)?trim(self.match[0]):''
  "let node.comm  = (len(self.match)>=2)?trim(self.match[1]):''

  "return node

"endf "}

" }
so plug/flux/autoload/flux.vim
so plug/file/autoload/file.vim

let tree = flux#flux('data/flux/data')

echo tree

finish


fu! file#copy(orig,dest) "{
  return 1+writefile(file#read(a:orig),a:dest)
endf "}
